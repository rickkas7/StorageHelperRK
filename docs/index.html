<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StorageHelperRK: StorageHelperRK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StorageHelperRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="class_storage_helper_r_k.html" title="Class for storing data on a variety of different storage media.">StorageHelperRK</a> </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a>Library for storing data in EEPROM, file system, SD card, FRAM, etc. on Particle devices</p>
<h1>Persistent Data</h1>
<p >This library makes makes it easy to store simple persistent data on a variety of storage mechanisms including:</p>
<ul>
<li>Retained memory</li>
<li>FRAM (MB85RCxx connected by I2C)</li>
<li>Emulated EEPROM in Device OS</li>
<li>POSIX flash filesystem (Particle Gen 3 devices and P2)</li>
<li>SdFat (Micro SD card)</li>
<li>Spiffs (SPI flash chips)</li>
</ul>
<p >It's possible to add additional storage mechanisms by creating a subclass. It's not necessary to modify the library to add new storage mechanisms.</p>
<h2>Data storage</h2>
<ul>
<li>Data includes C/C++ primitive types (int, float, double, bool, and other types like uint32_t) and C-strings of up to a maximum length that you configure.</li>
<li>Data is always cached in RAM, so it can be read quickly and efficiently, with no latency and low overhead.</li>
<li>You typically write simple get and set accessor functions for your data fields, so the correct data type is passed and returned.</li>
<li>Data is stored in binary format on your underlying storage method for efficiency.</li>
<li>Data is extensible in future versions of your code. While you cannot modify the existing fields in any way, you can add additional data at the end of the structure. If the data on disk is smaller than the current structure, it is zeroed out.</li>
<li>Data integrity detection includes magic bytes, length and version information, and a 32-bit hash of the data. These must match for be considered valid.</li>
<li>Deferred updates can be enabled which allow you to save values frequently, but write them to storage less often to avoid flash wear and to not slow down the thread that is updating.</li>
<li>The code is thread safe and can be used from loop, worker threads, or software timers.</li>
</ul>
<h2>Example</h2>
<p >This is from the example 04-persistent.cpp. This is the code you're write for your data.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;StorageHelperRK.h&quot;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">SerialLogHandler logHandler(LOG_LEVEL_INFO);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">SYSTEM_THREAD(ENABLED);</div>
<div class="line">SYSTEM_MODE(SEMI_AUTOMATIC);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *persistentDataPath = <span class="stringliteral">&quot;/usr/test04.dat&quot;</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyPersistentData : <span class="keyword">public</span> StorageHelperRK::PersistentDataFile {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">class </span>MyData {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="comment">// This structure must always begin with the header (16 bytes)</span></div>
<div class="line">        <a class="code hl_class" href="class_storage_helper_r_k_1_1_persistent_data_base_1_1_saved_data_header.html">StorageHelperRK::PersistentDataBase::SavedDataHeader</a> header;</div>
<div class="line">        <span class="comment">// Your fields go here. Once you&#39;ve added a field you cannot add fields</span></div>
<div class="line">        <span class="comment">// (except at the end), insert fields, remove fields, change size of a field.</span></div>
<div class="line">        <span class="comment">// Doing so will cause the data to be corrupted!</span></div>
<div class="line">        <span class="comment">// You may want to keep a version number in your data.</span></div>
<div class="line">        <span class="keywordtype">int</span> test1;</div>
<div class="line">        <span class="keywordtype">bool</span> test2;</div>
<div class="line">        <span class="keywordtype">double</span> test3;</div>
<div class="line">        <span class="keywordtype">char</span> test4[10];</div>
<div class="line">        <span class="comment">// OK to add more fields here </span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> uint32_t DATA_MAGIC = 0x20a99e74;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> uint16_t DATA_VERSION = 1;</div>
<div class="line"> </div>
<div class="line">    MyPersistentData() : PersistentDataFile(persistentDataPath, &amp;myData.header, sizeof(MyData), DATA_MAGIC, DATA_VERSION) {};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> getValue_test1()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> getValue&lt;int&gt;(offsetof(MyData, test1));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setValue_test1(<span class="keywordtype">int</span> value) {</div>
<div class="line">        setValue&lt;int&gt;(offsetof(MyData, test1), value);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> getValue_test2()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> getValue&lt;bool&gt;(offsetof(MyData, test2));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setValue_test2(<span class="keywordtype">bool</span> value) {</div>
<div class="line">        setValue&lt;bool&gt;(offsetof(MyData, test2), value);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> getValue_test3()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> getValue&lt;double&gt;(offsetof(MyData, test3));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setValue_test3(<span class="keywordtype">double</span> value) {</div>
<div class="line">        setValue&lt;double&gt;(offsetof(MyData, test3), value);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    String getValue_test4()<span class="keyword"> const </span>{</div>
<div class="line">        String result;</div>
<div class="line">        getValueString(offsetof(MyData, test4), <span class="keyword">sizeof</span>(MyData::test4), result);</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> setValue_test4(<span class="keyword">const</span> <span class="keywordtype">char</span> *str) {</div>
<div class="line">        <span class="keywordflow">return</span> setValueString(offsetof(MyData, test4), <span class="keyword">sizeof</span>(MyData::test4), str);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> logData(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg) {</div>
<div class="line">        Log.info(<span class="stringliteral">&quot;%s: %d, %d, %lf, %s&quot;</span>, msg, myData.test1, (<span class="keywordtype">int</span>)myData.test2, myData.test3, myData.test4);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    MyData myData;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">MyPersistentData persistentData;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">    <span class="comment">// Load the persistent data</span></div>
<div class="line">    persistentData.setup();</div>
<div class="line"> </div>
<div class="line">    Particle.connect();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> loop() {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lastCheck = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (millis() - lastCheck &gt;= 10000) {</div>
<div class="line">        lastCheck = millis();</div>
<div class="line"> </div>
<div class="line">        persistentData.setValue_test1(persistentData.getValue_test1() + 1);</div>
<div class="line">        persistentData.setValue_test2(!persistentData.getValue_test2());</div>
<div class="line">        persistentData.setValue_test3(persistentData.getValue_test3() - 0.1);</div>
<div class="line">        persistentData.setValue_test4(<span class="stringliteral">&quot;testing!&quot;</span>); </div>
<div class="line">        persistentData.flush(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">        persistentData.logData(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line">    }  </div>
<div class="line">}</div>
<div class="ttc" id="aclass_storage_helper_r_k_1_1_persistent_data_base_1_1_saved_data_header_html"><div class="ttname"><a href="class_storage_helper_r_k_1_1_persistent_data_base_1_1_saved_data_header.html">StorageHelperRK::PersistentDataBase::SavedDataHeader</a></div><div class="ttdoc">Header at the beginning of all saved data stored in RAM, retained memory, or a file.</div><div class="ttdef"><b>Definition:</b> StorageHelperRK.h:565</div></div>
</div><!-- fragment --><h3>Code walk-through</h3>
<p >You implement a subclass for your data. In this case, it's called <code>MyPersistentData</code> but you probably will want a more application-specific name.</p>
<p >The second part of the statement is what you are subclassing, and will be one of:</p>
<ul>
<li>StorageHelperRK::PersistentDataFile data in a file (POSIX, SdFat, SPIFFS)</li>
<li><a class="el" href="class_storage_helper_r_k_1_1_persistent_data_retained.html" title="Class for persistent data stored in retained memory.">StorageHelperRK::PersistentDataRetained</a> for retained memory</li>
<li><a class="el" href="class_storage_helper_r_k_1_1_persistent_data_e_e_p_r_o_m.html" title="Class for persistent data stored in emulated EEPROM.">StorageHelperRK::PersistentDataEEPROM</a> for the emulated EEPROM in Particle Device OS</li>
<li>StorageHelperRK::PersistentDataFRAM for MB85RCxx I2C FRAM</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyPersistentData : <span class="keyword">public</span> StorageHelperRK::PersistentDataFile {</div>
</div><!-- fragment --><p >The next part is the description of your actual data you want to store.</p>
<ul>
<li>The structure must always begin with <code><a class="el" href="class_storage_helper_r_k_1_1_persistent_data_base_1_1_saved_data_header.html" title="Header at the beginning of all saved data stored in RAM, retained memory, or a file.">StorageHelperRK::PersistentDataBase::SavedDataHeader</a> header;</code>. This structure adds 16 bytes of overhead and contains the magic bytes, version information, hash. etc.</li>
<li>You can add additional fields are desired for your application using C/C++ primitive types.</li>
<li>You can also add c-string variables. In this example test4 can be up to 9 characters. If you pass a value longer than that for set, the value will be truncated.</li>
<li>Once you release software with a data structure, you must never modify the existing fields, including resizing string fields or reordering fields.</li>
<li>You can, however, add additional fields at the end at any time.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyData {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_class" href="class_storage_helper_r_k_1_1_persistent_data_base_1_1_saved_data_header.html">StorageHelperRK::PersistentDataBase::SavedDataHeader</a> header;</div>
<div class="line">    <span class="keywordtype">int</span> test1;</div>
<div class="line">    <span class="keywordtype">bool</span> test2;</div>
<div class="line">    <span class="keywordtype">double</span> test3;</div>
<div class="line">    <span class="keywordtype">char</span> test4[10];</div>
<div class="line">    <span class="comment">// OK to add more fields here </span></div>
<div class="line">};</div>
</div><!-- fragment --><ul>
<li>The magic bytes are 4 random bytes that you pick that identify your data structure. Since retained memory, EEPROM, etc. could contain contents left over from a previous application, this helps prevent invalid data from being used. If you completely change your data structure, you may want to pick new magic bytes.</li>
<li>There is also a version field. If either the magic bytes or version do not match, the existing data will be erased.</li>
<li>Do not update the version when simply adding fields at the end of the structure!</li>
<li>The constructor declaration is boilerplate that will typically look something like this, though the parameters before <code>&amp;myData.header</code> may be different.</li>
<li>For file systems, the first parameter is the path to the file to store the data.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint32_t DATA_MAGIC = 0x20a99e74;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint16_t DATA_VERSION = 1;</div>
<div class="line"> </div>
<div class="line">MyPersistentData() : PersistentDataFile(persistentDataPath, &amp;myData.header, sizeof(MyData), DATA_MAGIC, DATA_VERSION) {};</div>
</div><!-- fragment --><p >Next we define accessor functions (get/set) for each of our variables. These are straightforward mappings between the type of data and the member in the class that holds the data.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> getValue_test1()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> getValue&lt;int&gt;(offsetof(MyData, test1));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setValue_test1(<span class="keywordtype">int</span> value) {</div>
<div class="line">    setValue&lt;int&gt;(offsetof(MyData, test1), value);</div>
<div class="line">}</div>
</div><!-- fragment --><p >The only one that's a little different are strings.</p>
<ul>
<li>In the data structure, strings are always stored as c-strings, null-terminated.</li>
<li>The maximum length of the string is defined when you declare the structure.</li>
<li>You cannot resize the maximum field size after releasing a version without changing the version, which erases any previously saved data of the old version when loaded.</li>
<li>If you pass too long of a string to setValue, the string will be truncated.</li>
</ul>
<div class="fragment"><div class="line">String getValue_test4()<span class="keyword"> const </span>{</div>
<div class="line">    String result;</div>
<div class="line">    getValueString(offsetof(MyData, test4), <span class="keyword">sizeof</span>(MyData::test4), result);</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">bool</span> setValue_test4(<span class="keyword">const</span> <span class="keywordtype">char</span> *str) {</div>
<div class="line">    <span class="keywordflow">return</span> setValueString(offsetof(MyData, test4), <span class="keyword">sizeof</span>(MyData::test4), str);</div>
<div class="line">}</div>
</div><!-- fragment --><p >A log function is optional, but you may find it useful for debugging.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> logData(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg) {</div>
<div class="line">    Log.info(<span class="stringliteral">&quot;%s: %d, %d, %lf, %s&quot;</span>, msg, myData.test1, (<span class="keywordtype">int</span>)myData.test2, myData.test3, myData.test4);</div>
<div class="line">}</div>
</div><!-- fragment --><p >You generally allocate an instance of the class on the heap. You don't have to worry about global constructor ordering because essentially nothing is done in the constructor.</p>
<div class="fragment"><div class="line">MyPersistentData persistentData;</div>
</div><!-- fragment --><p >In setup(), however, you must initialize the object. This will load it from the file system, in this case, and initialize the structure if the file is not present or is invalid.</p>
<ul>
<li>If the file does not exist the file will be initialized to zero values and empty strings</li>
<li>If the file has invalid magic bytes, version, or hash, it will be reinitialized to zero values</li>
<li>If the file contains data that is smaller than the current version, but is otherwise valid, then it will be preserved and only new values will be set to 0.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">    <span class="comment">// Load the persistent data</span></div>
<div class="line">    persistentData.setup();</div>
</div><!-- fragment --><p >Finally, you can get and set values as needed in your code.</p>
<div class="fragment"><div class="line">persistentData.setValue_test1(persistentData.getValue_test1() + 1);</div>
</div><!-- fragment --><p >If you set a value to the same value that it was before, no attempt will be made to save since for efficiency and to limit flash wear.</p>
<h1>Deferred save</h1>
<p >The library supports deferred save mode, which does not save the contents immediately after setting value.</p>
<p >Use the withSaveDelayMs() method to set the number of milliseconds to wait after changing data to save it. This is especially useful if you tend to set multiple fields at the same time.</p>
<p >Call the flush() method with the false parameter from loop(). This will save any deferred saves if necessary. This call is very fast with the false parameter so you can call it on every loop.</p>
<p >The example 05-eeprom uses deferred save mode.</p>
<p >Ideally, you will also want to call flush with the true parameter:</p>
<ul>
<li>Before system reset, via a reset system event handler</li>
<li>Before sleep, which will be dependent on your code</li>
</ul>
<p >When using the SleepHelper library, all of these things are taken care of automatically.</p>
<h2>Manual save mode</h2>
<p >You can also use the library in manual save mode. Use withSaveDelayMs with a non-zero value but do not call flush(false) from loop. Instead only call flush(true) when you want to save changes.</p>
<h1>File system abstraction</h1>
<p >There is a very limited file system abstraction as part of this library. It includes the bare minimum of functionality:</p>
<ul>
<li>open (with read, write, append, truncate, and/or create)</li>
<li>close</li>
<li>seek</li>
<li>read</li>
<li>write</li>
<li>truncate</li>
</ul>
<p >There are currently adapters for:</p>
<ul>
<li>POSIX (Particle Gen 3 devices)</li>
<li>SdFat (Micro SD card)</li>
<li>Spiffs (SPI flash)</li>
</ul>
<p >You can add your own by subclassing FileSystemBase. Since a pointer to the FileSystemBase subclass object is passed to the PersistentDataFileSystem constructor, you can add new file systems without having to modify the library.</p>
<h1>Non-file subclasses</h1>
<p >You can also subclass PersistentDataBase in the same way as PersistentDataEEPROM or PersistentDataBaseFRAM for things that aren't really files on a file system. This can also be done without modifying the library. You basically only need to implement the load and save methods. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
